var jsonfile = require('jsonfile'); 
var json2csv = require('json2csv');
var fs = require('fs');
var os = require('os');
var sys = require('sys');
var moment =require('moment');
var exec = require('child_process').exec;
var config = require('../../config');
var crypto = require("crypto");

function getStripeCustomers(file_name,format, app, all_customers, starting_after){
  console.log('fetch stripe customers');
  var stripe = require("stripe")(
       config.stripe_key
  );

  var stripe_params = { limit: 1000 };
  if(starting_after) stripe_params['starting_after'] = starting_after;
  stripe.customers.list(
      stripe_params,
      function(err,customers){
        if(err) console.log(err);

        var starting_after = customers.data[customers.data.length -1].id; 
        console.log(customers.data[0].email);

        if(all_customers){
              for(var i = 0; i < customers.data.length;i++){
                all_customers.data.push(customers.data[i]);
              }
              all_customers.has_more = customers.has_more;
              customers = all_customers;
        }

        if(customers.has_more){
          console.log('fetch more customers');
          console.log('starting_after:'+ starting_after);
          getStripeCustomers(file_name,format,app,customers,starting_after);
          return;
        }

        console.log('all customers fetched '+ customers.length);

        if(format == 'json'){
          console.log('saved as json');
          var f = file_name +'.json'; 
          jsonfile.writeFileSync(f,customers, {spaces:2}, function(err){
            console.log(err);
          });

          if(typeof app != 'undefined'){
            app.get('socket').emit('members',members());
          }
        }

        if(format == 'csv'){
          saveCustomersAsCSV(customers,file_name +'.csv');
          console.log('saved as csv');
        }
      }
  );
}

function getStripeCustomers_(file_name,format, app){
  console.log('fetch stripe customers');
  var stripe = require("stripe")(
       config.stripe_key
  );

  stripe.customers.list(
      { limit: 500 },
      function(err,customers){
        if(err) console.log(err);

        if(format == 'json'){
          console.log('saved as json');
          var f = file_name +'.json'; 
          jsonfile.writeFileSync(f,customers, {spaces:2}, function(err){
            console.log(err);
          });

          if(typeof app != 'undefined'){
            app.get('socket').emit('members',members());
          }
        }

        if(format == 'csv'){
          saveCustomersAsCSV(customers,file_name +'.csv');
          console.log('saved as csv');
        }
      }
  );
}

function saveCustomersAsCSV(customers,file_name){
  var c = listMembers(customers);
  json2csv({data:c},function(err,csv){
    if(err) console.log(err);

    fs.writeFile(file_name,csv,function(err){
        if(err) throw err;
        console.log('file saved');
    });

  });
}

function listMembers(members){
  var custs = [];
  for(var i = 0; i < members.data.length; i++){
    var customer  = members.data[i];
    var meta = customer.cards.data[0];

    var member_status = 'inactive';
    if(customer.subscriptions.data.length > 0){
      sub = customer.subscriptions.data[0]; 
      member_status = sub.status;
    }

    var is_admin = (customer.description === 'admin')? true:false;
    var card_uid = (customer.metadata.card_uid)? customer.metadata.card_uid:null;

    var c = {
             "stripeid": customer.id, 
             "delinquent":customer.delinquent,
             "email":customer.email, 
             "name":meta.name, 
             "address":meta.address_line1, 
             "zip":meta.address_zip, 
             "city":meta.address_city,
             "country":meta.address_country,
             "member_since":new Date(customer.created * 1000).toDateString(),
             "member_status":member_status,
             "card_uid":card_uid,
             "is_admin":is_admin
            };

	  c.photo = memberPhoto(customer.id); 
    custs.push(c);
  }

  return custs.sort(function(a,b){
    var statuses = {'active':1,'past_due':2,'inactive':3}
    var aa = statuses[a.member_status];
    var bb = statuses[b.member_status];
    if(!aa) aa = 4;
    if(!bb) bb = 4;
    return aa - bb; 
  });
}
  
function loadMembers(){
  var members = jsonfile.readFileSync('customers.json');
  saveCustomersAsCSV(members,'customer3.csv');
}

function currentExport(){
  var file_name = 'members_'+ new Date().toDateString().split(' ').join('_');
  getStripeCustomers(file_name ,'csv');
}

function members(){
  var members = jsonfile.readFileSync('data/customers.json');
  return {synced:membersSyncDate(),data:listMembers(members) };
}

function membersSyncDate(){
  return fs.statSync('data/customers.json').ctime;
}

function syncMembers(app){
  getStripeCustomers('data/customers','json',app);
  return {status:'ok'};
}

function memberPhoto(id){
  var path = config.app_folder +'/public/members/'+ id +'.png';
  try {
  	if(fs.existsSync(path)){
		var m = '/members/'+ id +'.png'
		return m;
	}
  } catch(e){
	console.log(e);
	return '';
  }
}

function member(id){
  var cs = members().data;
  for(var i = 0; i < cs.length;i++){
    if(cs[i].stripeid == id) {
	var m = cs[i];
	m.photo = memberPhoto(id); 
	return m;
    }
  }
  return {};
}

function customerByCardID(card_uid){
  var cs = members().data;
  for(var i = 0; i < cs.length;i++){
    if(cs[i].card_uid === card_uid) return cs[i];
  }
  return null;
}

function access(card_uid){
  var customer = customerByCardID(card_uid);

  if(customer === null){
    appendLog('KO',card_uid,'Ingen bruger for kort',null);
    return {status:'KO',message:'Ingen bruger tilknyttet kort med id '+ card_uid };
  }

  //check if the user is an active member
  if(customer.member_status != 'active'){
    //log the access
    appendLog('KO',card_uid,'Bruger ikke aktiv '+ customer.name, customer.stripeid);
    return {status:'KO',message:'Din meddelemskab er ikke aktive '+ customer.name };
  }

  //check if the user is board member
  if(customer.is_admin){
    //log the access
    appendLog('OK',card_uid,'Adgang til bestyrelses medlem '+ customer.name, customer.stripeid);
    return {status:'OK',message:'Velkommen til Fablab NV '+ customer.name +'!' };
  }

  //check if there is open for alle or one the groups the user is part of
  if(isCurrentlyOpenForGroup(groupsforUser(customer.stripeid)))
  {
    appendLog('OK',card_uid,'Åben, adgang til '+ customer.name, customer.stripeid);
    return {status:'OK',message:'Velkommen til Fablab NV '+ customer.name +'!' };
  }

  appendLog('KO',card_uid,'Lukket, ingen adgang til '+ customer.name, customer.stripeid);
  return {status:'KO',message:'Beklager '+ customer.name +' du har ikke adgang på denne tidspunkt af dagen'};

}
function appendLog(stat, card_uid, message, customer_stripeid){
  var logs = getLogs(null);
  var log = { 'timestamp': Date.now(),
              'status': stat,
              'card_uid': card_uid,
              'stripeid': customer_stripeid,
              'message':message };

  logs.push(log);

  //write the events to the log
  jsonfile.writeFileSync('data/access_log.json',logs, {spaces:2}, function(err){
    console.log(err);
  });
}

function saveGroups(groups){
  //write the events to the log
  jsonfile.writeFileSync('data/groups.json',groups, {spaces:2}, function(err){
    console.log(err);
  });
}

function addGroup(group_name){
  var groups = userGroups();
  var id = crypto.randomBytes(16).toString('hex');
  groups.push({id:id,name:group_name,members:[]});
  saveGroups(groups);
  return groups;
}

function removeGroup(group_idx){
  var groups = userGroups();
  groups.splice(group_idx,1);
  saveGroups(groups);
  return groups;
}
function addMemberToGroup(idx,stripeid){
  var groups = userGroups();
  if(!groups[idx].members) groups[idx].members = [];
  groups[idx].members.push(stripeid);
  saveGroups(groups);
  return groups;
}

function removeMemberFromGroup(idx,stripeid){
  var groups = userGroups();
  if(!groups[idx].members) groups[idx].members = [];
  var mems = [];
  for(var i = 0; i < groups[idx].members.length;i++){
    if(groups[idx].members[i] == stripeid) continue;
    mems.push(groups[idx].members[i]);
  }
  groups[idx].members = mems;
  saveGroups(groups);
  return groups;
}

function userGroups(){
  var groups = [];
  var path = 'data/groups.json';
  if (!fs.existsSync(path)) return groups;

  try {
    groups = jsonfile.readFileSync(path);
  } catch(err){
    console.log('---Error on reading groups ----');
    console.log(err);
  }
  return groups;
}

function openingPeriods(){
  var openings = [];
  var path = 'data/openings.json';
  if (!fs.existsSync(path)) return openings;

  try {
    openings = jsonfile.readFileSync(path);
  } catch(err){
    console.log('---Error on reading openings----');
    console.log(err);
  }
  return openings;
}

function addOpening(){
  moment.locale('dk');
  var openings = openingPeriods();

  var dstart = moment().format('YYYY-MM-DD');
  var dend = moment().add(1,'y').format('YYYY-MM-DD');

  var opening = {
                  from:'17:00',
                  to:'20:00',
                  periodicity:['daily'],
                  date_start:dstart,
                  date_end:dend,
                  active:true,
                  groups:['Alle']
                 };
  openings.push(opening);
  saveOpenings(openings);
  return openings;
}

function saveOpening(idx,opening){
  console.log(opening);
  var openings = openingPeriods();
  openings[idx] = opening;
  saveOpenings(openings);
  return openings;
}

function removeOpening(idx){
  var openings = openingPeriods();
  openings.splice(idx,1);
  saveOpenings(openings);
  return openings;
}

function saveOpenings(openings){
  //write it to file
  jsonfile.writeFileSync('data/openings.json',openings, {spaces:2}, function(err){
    console.log(err);
  });
}

function logsWithMembers(limit){
  var logs = getLogs(limit);
  var ms = members().data;
  moment.locale('dk');

  for(var i = 0; i < logs.length; i++){
    logs[i].timestamp = moment(logs[i].timestamp).format('LLL');
    if(logs[i].stripeid != null){
      for(var j = 0; j < ms.length;j++){
        if(ms[j].stripeid === logs[i].stripeid){
          logs[i].member = ms[j];
          break;
        }
      }
    }
  }

  return logs;
}

function getLogs(limit){
  var  logs = [];
  try {
    logs = jsonfile.readFileSync('data/access_log.json');
  } catch(err){
    console.log('---Error on reading logs----');
    console.log(err);
    logs = [];
  }

  if(limit != null) logs = logs.slice(limit * -1).reverse();
  return logs;
}

function addCardToCustomer(card_uid,stripeid,app){

  var stripe = require("stripe")(
       config.stripe_key
  );

  stripe.customers.update(stripeid,
                          { metadata:{card_uid:card_uid} }, 
                          function(err,customer){
                            if(err){
                              console.log(err);
                              return {status:'KO',msg:err};
                            }

                            //fetch new customer list
                            syncMembers(app);

                            return {status:'OK',message:'card registred' };
                          });
}

function revokeCardFromCustomer(stripeid,app){

  var stripe = require("stripe")(
       config.stripe_key
  );

  stripe.customers.update(stripeid,
                          { metadata:null }, 
                          function(err,customer){
                            if(err){
                              console.log('fail to update');
                              console.log(err);
                              return;
                            }

                            //fetch new customer list
                            syncMembers(app);

                            return {status:'OK',message:'card revoked' };
                          });
}

function openinghours(){
  var openinghours = null;
  try {
    openinghours = jsonfile.readFileSync('data/openinghours.json');
  } catch(err){
    openinghours = {"from_hour":"09","from_minute":"15","to_hour":"23","to_minute":"30"};
  }
  return openinghours;
}

function save_openinghours(dat){
  var f = 'data/openinghours.json'; 
  jsonfile.writeFileSync(f,dat, {spaces:2}, function(err){
    console.log(err);
  });
  return dat;
}

function isAdminByCard(card_uid){
  var cs = members().data;
  for(var i = 0; i < cs.length; i++){
    if(cs[i].card_uid != card_uid) continue;
    if(!cs[i].is_admin) return null;
    return cs[i];
  }
  return null;
}

function groupsforUser(stripeid){
  //
  var gs = ['Alle'];
  var groups = userGroups();
  for(var i=0; i < groups.length;i++){
    for(var j = 0; j < groups[i].members.length; j++){
      if(stripeid == groups[i].members[j]) gs.push(groups[i].name);
    }
  }
  return gs;
}

function isCurrentlyOpenForGroup(groups){
  //find openings relevant for the groups
  var openings = openingPeriods();
  for(var i = 0; i < openings.length;i++){
    //check if it's active
    if(!openings[i].active) continue;
    if(!haveMatchingGroup(groups, openings[i].groups)) continue;
    //this opening is relevant check if the period match
    if(!currentMomentMatchOpening(openings[i])) continue;
    
    return true;
  }

  return false;
}

function currentMomentMatchOpening(opening){
  var now = moment();

  //check if the opening has a date end that's overdue
  if(opening.date_end){
    var date_end = moment(opening.date_end);
    if(date_end.isBefore(now)) return false;
  }
  //check if the opening has a date start that's two early
  if(opening.date_start){
    var date_start = moment(opening.date_start);
    if(now.isBefore(date_start)){
      return false;
    }
  }
  //if not daily in periodicity check if the day match
  var p_ok = false;
  for(var i = 0; i < opening.periodicity.length; i++){
    var p = opening.periodicity[i];
    if(p == 'daily'){
      p_ok = true;
      break;
    }

    if(moment().format('dddd').toLowerCase() == p){
      p_ok = true;
      break;
    }
  }

  if(!p_ok) return false;

  //check that the time is after or equal to from
  var from_hour = new moment();
  from_hour.hour(opening.from.split(':')[0]);
  from_hour.minute(opening.from.split(':')[1]);

  if(from_hour.isAfter(now)) return false;

  //check that the time is before or equal to to
  var to_hour = new moment();
  to_hour.hour(opening.to.split(':')[0]);
  to_hour.minute(opening.to.split(':')[1]);

  if(to_hour.isBefore(now)) return false;

  return true;
}

function haveMatchingGroup(groups,opening_groups){
  for(var i = 0; i < groups.length;i++){
    for(var j = 0; j < opening_groups.length; j++){
        if(groups[i] == opening_groups[j]) return true;
    }
  }
  return false;
}

function isAdmin(stripeid){
  var cs = members().data;
  for(var i = 0; i < cs.length; i++){
    if(cs[i].stripeid != stripeid) continue;
    return cs[i].is_admin;
  }
  return false;
}

function revokeAdminRights(stripeid){

  var stripe = require("stripe")(
       config.stripe_key
  );

  stripe.customers.update(stripeid,
                          { description:null}, 
                          function(err,customer){
                            if(err){
                              console.log(err);
                              return;
                            }

                            //fetch new customer list
                            syncMembers();
                          });
}

function shutdown(){
	exec('sudo halt',function(err,stdout,stderr){
		console.log(err);
		console.log(stderr);
		console.log(stdout);
		return err;
	});	
	return 'OK';
}

function currentIP(){
	var interfaces = os.networkInterfaces();
	var addresses = [];
	for(var k in interfaces){
		for(var k2 in interfaces[k]){
			var address = interfaces[k][k2];
			if(address.family === 'IPv4' && !address.internal){
				addresses.push(address.address);
			}
		}
	}
	return addresses.join(', ');
}

function savephoto(name,img){
	//copy file
	var path = config.app_folder +'/public/'+ name;
  var data = img.replace(/^data:image\/\w+;base64,/, "");
  var buf = new Buffer(data, 'base64');

  fs.writeFile(path, buf, function(err){
		if(err){ 
			console.log('fail to save photo');
			console.log(err);
		 }
		return '/'+ name; 
  });
}

function addAdminRights(stripeid){

  var stripe = require("stripe")(
       config.stripe_key
  );

  stripe.customers.update(stripeid,
                          { description:"admin"}, 
                          function(err,customer){
                            if(err){
                              console.log(err);
                              return;
                            }

                            //fetch new customer list
                            syncMembers();
                          });
}

function saveMessage(message_id,content){
  var messages = allMessages();
  var m = [];
  for(var i = 0; i < messages.length;i++){
    if(messages[i].id == message_id) 
    {
        messages[i].content = content;
        messages[i].edited = moment().format();
    }
    m.push(messages[i]);
  }
  saveMessages(m);
  return m;
}

function removeMessage(message_id){
  var messages = allMessages();
  var m = [];
  for(var i = 0; i < messages.length;i++){
    if(messages[i].id == message_id) continue;
    m.push(messages[i]);
  }
  saveMessages(m);
  return m;
}

function addMessage(){
  var messages = allMessages();
  var id = crypto.randomBytes(16).toString('hex');
  messages.push({
                 id:id,
                 content:'ny besked',
                 edited: moment().format()
                });
  saveMessages(messages);
  return messages;
}

function saveMessages(messages){
  jsonfile.writeFileSync('data/messages.json',messages, {spaces:2}, function(err){
    console.log(err);
  });
}

function allMessages(){
  var messages = [];
  var path = 'data/messages.json';
  if (!fs.existsSync(path)) return messages;

  try {
    messages = jsonfile.readFileSync(path);
  } catch(err){
    console.log('---Error on reading messages----');
    console.log(err);
  }
  return messages;
}

var fablab = {
  members: members,
  member: member,
  openinghours:openinghours,
  save_openinghours:save_openinghours,
  logs:logsWithMembers,
  userGroups:userGroups,
  addGroup:addGroup,
  removeGroup:removeGroup,
  addMemberToGroup:addMemberToGroup,
  removeMemberFromGroup:removeMemberFromGroup,
  openings:openingPeriods,
  addOpening:addOpening,
  saveOpening:saveOpening,
  removeOpening:removeOpening,
  getLogs:getLogs,
  appendLog:appendLog,
  isAdmin:isAdmin,
  isAdminByCard:isAdminByCard,
  addAdminRights:addAdminRights,
  revokeAdminRights:revokeAdminRights,
  membersSyncDate:membersSyncDate,
  syncMembers:syncMembers,
  addCardToCustomer:addCardToCustomer,
  revokeCardFromCustomer:revokeCardFromCustomer,
  currentIP:currentIP,
  haveMatchingGroup:haveMatchingGroup,
  currentMomentMatchOpening:currentMomentMatchOpening,
  shutdown:shutdown,
  access:access,
  savephoto:savephoto,
  addMessage:addMessage,
  removeMessage:removeMessage,
  saveMessage:saveMessage,
  allMessages:allMessages
}

module.exports = fablab
